var z=()=>{},Be=String.fromCharCode,ve=Promise.resolve.bind(Promise),fe=Promise.reject.bind(Promise),D=()=>new Promise(z),{from:Ue,isArray:be,of:Ke}=Array,{isInteger:Le,MAX_VALUE:Ye,NEGATIVE_INFINITY:Ge,POSITIVE_INFINITY:ze}=Number,{assign:De,defineProperty:Xe,entries:He,fromEntries:Je,keys:Ie,getPrototypeOf:Qe,values:Ee}=Object,Se=Date.now,{iterator:We,toStringTag:Ze}=Symbol,A=a=>a.prototype,c=(a,t,...e)=>s=>a[t].bind(s,...e),X=(a,t,...e)=>a[t].bind(a,...e),x=A(Array),M=A(Map),C=A(Set),we=c(x,"pop"),H=c(x,"push"),Me=c(x,"splice",0),j=c(C,"add"),J=c(C,"clear"),Q=c(C,"delete"),W=c(C,"has"),Z=c(M,"clear"),O=c(M,"delete"),E=c(M,"get"),I=c(M,"set"),$=Symbol("a rejection by a throttled function"),Ce=(a,t)=>{let e=0;return(...s)=>{let i=Se();return i-e>a?(e=i,t(...s)):$}},ee=(a,t)=>a===t,te=(a,t)=>!1,se=a=>a===!1?te:a??ee,Pe=(a,t)=>{let e=se(t),s=Ce(a,e);return(i,l)=>{let o=s(i,l);return o===$?!0:o}},Te=a=>{let t=a.length**.5;return a.reduce((e,s)=>e+s*(s+t),0)},$e=z,f=a=>{let{newId:t,getId:e,setId:s,addEdge:i}=a;return class{constructor(l,{name:o,equals:u}={}){let m=t();s(m,this),this.id=m,this.rid=m,this.name=o,this.value=l,this.equals=se(u)}get(l){return l&&i(this.id,l),this.value}set(l){let o=this.value;return!this.equals(o,this.value=typeof l=="function"?l(o):l)}run(l){return l?1:0}bindMethod(l){return X(this,l)}static create(...l){let o=new this(...l);return[o.id,o]}}},qe=a=>{let t=a.runId;return class extends a.getClass(f){constructor(e,s){super(e,s)}set(e){return super.set(e)?(t(this.id),!0):!1}static create(e,s){let i=new this(e,s);return[i.id,i.bindMethod("get"),i.bindMethod("set")]}}},Fe=a=>class extends a.getClass(f){constructor(t,e){super(e?.value,e),this.fn=t,e?.defer===!1&&this.get()}get(t){return this.rid&&(this.run(),this.rid=0),super.get(t)}run(t){return super.set(this.fn(this.rid))?1:0}static create(t,e){let s=new this(t,e);return[s.id,s.bindMethod("get")]}},Ne=a=>class extends a.getClass(f){constructor(t,e){super(e?.value,e),this.fn=t,this.dirty=1,e?.defer===!1&&this.get()}run(t){return this.dirty=1}get(t){return(this.rid||this.dirty)&&(super.set(this.fn(this.rid)),this.dirty=1,this.rid=0),super.get(t)}static create(t,e){let s=new this(t,e);return[s.id,s.bindMethod("get")]}},Ae=a=>{let t=a.runId;return class extends a.getClass(f){constructor(e,s){super(void 0,s),this.fn=e,s?.defer===!1&&this.set()}get(e){e&&(this.rid&&this.run(),super.get(e))}set(){return t(this.id)}run(e){let s=this.fn(this.rid)!==!1;return this.rid&&(this.rid=0),s?1:0}static create(e,s){let i=new this(e,s);return[i.id,i.bindMethod("get"),i.bindMethod("set")]}}},xe=a=>{let t=a.runId;return class extends a.getClass(f){promise;constructor(e,s){super(e,s)}setPromise(e,s=!1){let i=this;return e=typeof e=="function"&&!(e instanceof Promise)?e(i.value):e,e instanceof Promise?(i.promise=e).then(l=>i.promise===e?(i.promise=void 0,i.setPromise(l,s)):D(),l=>(i.promise===e&&(i.promise=void 0),s?fe(l):D())):(super.set(e)&&t(this.id),ve(e))}run(e){return this.promise?-1:super.run(e)}static create(e,s){let i=new this(e,s);return[i.id,i.bindMethod("get"),i.bindMethod("setPromise")]}}},je=class{addEdge;delEdge;newId;getId;setId;delId;runId;swapId;clearCache;addClass;getClass;batch;dynamic;constructor(){let a=0,t=0,e=new Map,s=new Map,i=E(e),l=E(s),o=I(e),u=I(s),m=O(e),P=O(s),p=new Map,b=E(p),S=I(p),g=Z(p),T=r=>{let n=new Set,_=j(n),d=W(n),h=v=>{d(v)||(i(v)?.forEach(h),_(v))};return r.forEach(h),r.forEach(Q(n)),[...n,...r].reverse()},re=(...r)=>{let n=Te(r);return b(n)??(S(n,T(r))&&b(n))},q=new Map,y=E(q),F=I(q),ie=O(q),w=new Set,k=j(w),ae=Q(w),ne=J(w),N=new Set,le=j(N),_e=W(N),oe=J(N),R=new Map,ke=I(R),Re=Z(R),B=[],de=H(B),he=we(B),U=(...r)=>{ne(),oe(),r.forEach(k);let n=r.length,_=re(...r);for(let h of _){if(ae(h)&&!_e(h)){let v=ce(h,n-- >0);v!==0&&i(h)?.forEach(v>=1?k:le)}if(w.size<=0)break}let d;for(;d=he();)y(d)?.postrun()},ce=(r,n)=>{let _=n===!0,d=y(r),h=d?.run(_)??0;return h>=1&&d.postrun&&de(r),h},K=[],ue=H(K),ge=Me(K),L=()=>++t,Y=()=>{--t<=0&&(t=0,U(...ge()))},pe=(r,...n)=>{L();let _=r(...n);return Y(),_};this.addEdge=(r,n)=>{if(r+n<=0)return!1;let _=i(r)??(o(r,new Set)&&i(r));return _.has(n)?!1:(_.add(n),l(n)?.add(r)||u(n,new Set([r])),g(),!0)},this.delEdge=(r,n)=>i(r)?.delete(n)&&l(n)?.delete(r)?(g(),!0):!1,this.newId=()=>(g(),++a),this.getId=y,this.setId=F,this.delId=r=>{if(ie(r)){let n=i(r),_=l(r);return n?.forEach(d=>{l(d)?.delete(r)}),_?.forEach(d=>{i(d)?.delete(r)}),n?.clear(),_?.clear(),m(r),P(r),g(),!0}return!1},this.swapId=(r,n)=>{let _=y(r),d=y(n);F(r,d),F(n,_),_&&(_.id=n,_.rid&&(_.rid=n)),d&&(d.id=r,d.rid&&(d.rid=r)),g()},this.clearCache=g,this.runId=r=>t<=0?(U(r),!0):(ue(r),!1);let G=new Map,ye=E(G),me=I(G);this.addClass=r=>{let n=this.getClass(r);return X(n,"create")},this.getClass=r=>{let n=ye(r);return n||(n=r(this),me(r,n),n)},this.batch={startBatching:L,endBatching:Y,scopedBatching:pe},this.dynamic={setValue:(r,n)=>{let _=y(r??0);_&&(_.value=n)},setEquals:(r,n)=>{let _=y(r??0);_&&(_.equals=n)},setFn:(r,n)=>{let _=y(r??0);_&&(_.fn=n)}}}},V=a=>class extends a.getClass(f){constructor(t={},e){let s=be(t),i=s?[]:{},l=s?[...t.keys()]:Ie(t),o=s?[...t.values()]:Ee(t);super([i],e),this.setItems(l,o,!1)}postrun(){this.value.splice(1)}set(t,e,s){return this.setItems([t],[e],s)}setItems(t,e,s){let i=this.equals,l=this.value,o=l.length,u=l[0],m=t.length;for(let p=0;p<m;p++){let b=t[p],S=u[b],g=e[p],T=u[b]=typeof g=="function"?g(S):g;!i(S,T)&&l.push(b)}let P=l.length;return!s&&P-o>0}delete(t,e){return this.deleteKeys([t],e)}deleteKeys(t,e){let s=this.value,i=s.length,l=s[0];for(let u of t)u in l&&(delete l[u],s.push(u));let o=s.length;return!e&&o-i>0}},Oe=a=>{let t=a.runId;return class extends a.getClass(V){setItems(e,s,i){return super.setItems(e,s,i)?t(this.id):!1}deleteKeys(e,s){return super.deleteKeys(e,s)?t(this.id):!1}static create(e={},s){let i=new this(e,s);return[i.id,i.bindMethod("get"),i.bindMethod("set"),i.bindMethod("setItems"),i.bindMethod("delete"),i.bindMethod("deleteKeys")]}}},Ve=a=>class extends a.getClass(V){constructor(t,e){super(e?.value,e),this.fn=t,e?.defer===!1&&this.get()}get(t){return this.rid&&(this.run(),this.rid=0),super.get(t)}run(t){let[e,s,i=!0]=this.fn(this.rid);return i&&super.setItems(e,s)?1:0}static create(t,e){let s=new this(t,e);return[s.id,s.bindMethod("get")]}};export{xe as AsyncStateSignal_Factory,je as Context,Ae as EffectSignal_Factory,Ne as LazySignal_Factory,Fe as MemoSignal_Factory,Ve as RecordMemoSignal_Factory,V as RecordSignal_Factory,Oe as RecordStateSignal_Factory,f as SimpleSignal_Factory,qe as StateSignal_Factory,ee as default_equality,te as falsey_equality,Pe as throttlingEquals};
