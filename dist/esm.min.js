var X=()=>{},Ye=String.fromCharCode,we=Promise.resolve.bind(Promise),Se=Promise.reject.bind(Promise),H=()=>new Promise(X),{from:Ge,isArray:Me,of:ze}=Array,{MAX_VALUE:Xe,NEGATIVE_INFINITY:He,POSITIVE_INFINITY:Je,isFinite:Qe,isInteger:We,isNaN:Ze,parseFloat:$e,parseInt:et}=Number,{random:tt}=Math,{assign:st,defineProperty:rt,entries:at,fromEntries:it,keys:Ce,getPrototypeOf:nt,values:Te}=Object,Fe=Date.now,{iterator:lt,toStringTag:ot}=Symbol,{assert:_t,clear:dt,debug:ct,dir:ut,error:ht,log:gt,table:pt}=console,{now:mt}=performance,j=n=>n.prototype,O=n=>typeof n=="function",u=(n,t,...e)=>s=>n[t].bind(s,...e),J=(n,t,...e)=>n[t].bind(n,...e),V=j(Array),M=j(Map),C=j(Set),Ne=u(V,"pop"),Q=u(V,"push"),Pe=u(V,"splice",0),R=u(C,"add"),W=u(C,"clear"),Z=u(C,"delete"),$=u(C,"has"),ee=u(M,"clear"),T=u(M,"delete"),E=u(M,"get"),v=u(M,"set"),yt=Symbol(1),te=Symbol(1),bt=Symbol(1),qe=(n,t)=>{let e=0;return(...s)=>{let a=Fe();return a-e>n?(e=a,t(...s)):te}},se=(n,t)=>n===t,re=(n,t)=>!1,ae=n=>n===!1?re:n??se,Ae=(n,t)=>{let e=ae(t),s=qe(n,e);return(a,l)=>{let _=s(a,l);return _===te?!0:_}},xe=n=>{let t=n.length**.5;return n.reduce((e,s)=>e+s*(s+t),0)},vt=X,f=n=>{let{newId:t,getId:e,setId:s,addEdge:a}=n;return class{constructor(l,{name:_,equals:h}={}){let y=t();s(y,this),this.id=y,this.rid=y,this.name=_,this.value=l,this.equals=ae(h)}get(l){return l&&a(this.id,l),this.value}set(l){let _=this.value;return!this.equals(_,this.value=O(l)?l(_):l)}run(l){return l?1:0}bindMethod(l){return J(this,l)}static create(...l){let _=new this(...l);return[_.id,_]}}},je=n=>{let t=n.runId;return class extends n.getClass(f){constructor(e,s){super(e,s)}set(e){return super.set(e)?(t(this.id),!0):!1}static create(e,s){let a=new this(e,s);return[a.id,a.bindMethod("get"),a.bindMethod("set")]}}},Oe=n=>class extends n.getClass(f){constructor(t,e){super(e?.value,e),this.fn=t,e?.defer===!1&&this.get()}get(t){return this.rid&&(this.run(),this.rid=0),super.get(t)}run(t){return super.set(this.fn(this.rid))?1:0}static create(t,e){let s=new this(t,e);return[s.id,s.bindMethod("get")]}},Ve=n=>class extends n.getClass(f){constructor(t,e){super(e?.value,e),this.fn=t,this.dirty=1,e?.defer===!1&&this.get()}run(t){return this.dirty=1}get(t){return(this.rid||this.dirty)&&(super.set(this.fn(this.rid)),this.dirty=0,this.rid=0),super.get(t)}static create(t,e){let s=new this(t,e);return[s.id,s.bindMethod("get")]}},Re=n=>{let t=n.runId;return class extends n.getClass(f){constructor(e,s){super(void 0,s),this.fn=e,s?.defer===!1&&this.set()}get(e){e&&(this.rid&&this.run(),super.get(e))}set(){return t(this.id)}run(e){let s=this.fn(this.rid)!==!1;return this.rid&&(this.rid=0),s?1:0}static create(e,s){let a=new this(e,s);return[a.id,a.bindMethod("get"),a.bindMethod("set")]}}},Ue=n=>{let t=n.runId;return class extends n.getClass(f){promise;constructor(e,s){super(e,s)}setPromise(e,s=!1){let a=this;return e=O(e)&&!(e instanceof Promise)?e(a.value):e,e instanceof Promise?(a.promise=e).then(l=>a.promise===e?(a.promise=void 0,a.setPromise(l,s)):H(),l=>(a.promise===e&&(a.promise=void 0),s?Se(l):H())):(super.set(e)&&t(this.id),we(e))}run(e){return this.promise?-1:super.run(e)}static create(e,s){let a=new this(e,s);return[a.id,a.bindMethod("get"),a.bindMethod("setPromise")]}}},ke=class{addEdge;delEdge;newId;getId;setId;delId;runId;swapId;onInit;onDelete;clearCache;addClass;getClass;batch;dynamic;constructor(){let n=0,t=0,e=new Map,s=new Map,a=E(e),l=E(s),_=v(e),h=v(s),y=T(e),F=T(s),p=new Map,I=E(p),w=v(p),g=ee(p),N=r=>{let i=new Set,o=R(i),d=$(i),c=b=>{d(b)||(a(b)?.forEach(c),o(b))};return r.forEach(c),r.forEach(Z(i)),[...i,...r].reverse()},ie=(...r)=>{let i=xe(r);return I(i)??(w(i,N(r))&&I(i))},P=new Map,m=E(P),q=v(P),ne=T(P),S=new Set,k=R(S),le=Z(S),oe=W(S),A=new Set,_e=R(A),de=$(A),ce=W(A),B=new Map,Ke=v(B),De=ee(B),L=[],ue=Q(L),he=Ne(L),K=(...r)=>{oe(),ce(),r.forEach(k);let i=r.length,o=ie(...r);for(let c of o){if(le(c)&&!de(c)){let b=ge(c,i-- >0);b!==0&&a(c)?.forEach(b>=1?k:_e)}if(S.size<=0)break}let d;for(;d=he();)m(d)?.postrun()},ge=(r,i)=>{let o=i===!0,d=m(r),c=d?.run(o)??0;return c>=1&&d.postrun&&ue(r),c},D=[],pe=Q(D),me=Pe(D),Y=()=>++t,G=()=>{--t<=0&&(t=0,K(...me()))},ye=(r,...i)=>{Y();let o=r(...i);return G(),o},x=new Map,be=E(x),ve=v(x),fe=T(x);this.onInit=(r,i)=>r?i():void 0,this.onDelete=(r,i)=>{r&&ve(r,i)},this.addEdge=(r,i)=>{if(r+i<=0)return!1;let o=a(r)??(_(r,new Set)&&a(r));return o.has(i)?!1:(o.add(i),l(i)?.add(r)||h(i,new Set([r])),g(),!0)},this.delEdge=(r,i)=>a(r)?.delete(i)&&l(i)?.delete(r)?(g(),!0):!1,this.newId=()=>(g(),++n),this.getId=m,this.setId=q,this.delId=r=>{if(ne(r)){let i=a(r),o=l(r);return i?.forEach(d=>{l(d)?.delete(r)}),o?.forEach(d=>{a(d)?.delete(r)}),i?.clear(),o?.clear(),y(r),F(r),g(),be(r)?.(),fe(r),!0}return!1},this.swapId=(r,i)=>{let o=m(r),d=m(i);q(r,d),q(i,o),o&&(o.id=i,o.rid&&(o.rid=i)),d&&(d.id=r,d.rid&&(d.rid=r)),g()},this.clearCache=g,this.runId=r=>t<=0?(K(r),!0):(pe(r),!1);let z=new Map,Ie=E(z),Ee=v(z);this.addClass=r=>{let i=this.getClass(r);return J(i,"create")},this.getClass=r=>{let i=Ie(r);return i||(i=r(this),Ee(r,i),i)},this.batch={startBatching:Y,endBatching:G,scopedBatching:ye},this.dynamic={setValue:(r,i)=>{let o=m(r??0);o&&(o.value=i)},setEquals:(r,i)=>{let o=m(r??0);o&&(o.equals=i)},setFn:(r,i)=>{let o=m(r??0);o&&(o.fn=i)}}}},U=n=>class extends n.getClass(f){constructor(t={},e){let s=Me(t),a=s?[]:{},l=s?[...t.keys()]:Ce(t),_=s?[...t.values()]:Te(t);super([a],e),this.setItems(l,_,!1)}postrun(){this.value.splice(1)}set(t,e,s){return this.setItems([t],[e],s)}setItems(t,e,s){let a=this.equals,l=this.value,_=l.length,h=l[0],y=t.length;for(let p=0;p<y;p++){let I=t[p],w=h[I],g=e[p],N=h[I]=O(g)?g(w):g;!a(w,N)&&l.push(I)}let F=l.length;return!s&&F-_>0}delete(t,e){return this.deleteKeys([t],e)}deleteKeys(t,e){let s=this.value,a=s.length,l=s[0];for(let h of t)h in l&&(delete l[h],s.push(h));let _=s.length;return!e&&_-a>0}},Be=n=>{let t=n.runId;return class extends n.getClass(U){setItems(e,s,a){return super.setItems(e,s,a)?t(this.id):!1}deleteKeys(e,s){return super.deleteKeys(e,s)?t(this.id):!1}static create(e={},s){let a=new this(e,s);return[a.id,a.bindMethod("get"),a.bindMethod("set"),a.bindMethod("setItems"),a.bindMethod("delete"),a.bindMethod("deleteKeys")]}}},Le=n=>class extends n.getClass(U){constructor(t,e){super(e?.value,e),this.fn=t,e?.defer===!1&&this.get()}get(t){return this.rid&&(this.run(),this.rid=0),super.get(t)}run(t){let[e,s,a=!0]=this.fn(this.rid);return a&&super.setItems(e,s)?1:0}static create(t,e){let s=new this(t,e);return[s.id,s.bindMethod("get")]}};export{Ue as AsyncStateSignal_Factory,ke as Context,Re as EffectSignal_Factory,Ve as LazySignal_Factory,Oe as MemoSignal_Factory,Le as RecordMemoSignal_Factory,U as RecordSignal_Factory,Be as RecordStateSignal_Factory,f as SimpleSignal_Factory,je as StateSignal_Factory,se as default_equality,re as falsey_equality,Ae as throttlingEquals};
